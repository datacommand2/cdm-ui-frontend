/* tslint:disable */
/* eslint-disable */
/**
 * CDM-DisasterRecovery
 * 설명추가
 *
 * The version of the OpenAPI document: v1
 * 
 *
 * NOTE: This class is auto generated by OpenAPI Generator (https://openapi-generator.tech).
 * https://openapi-generator.tech
 * Do not edit the class manually.
 */

import { exists, mapValues } from '../runtime';
/**
 * 클러스터 인스턴스 Extra Specification
 * @export
 * @interface ClusterInstanceExtraSpec
 */
export interface ClusterInstanceExtraSpec {
    /**
     * Extra Specification 의 Key
     * 
     * **CPU limits:**
     * - quota:cpu_shares - Specifies the proportional weighted share for the domain. If this element is omitted, the service defaults to the OS provided defaults. There is no unit for the value; it is a relative measure based on the setting of other VMs. For example, a VM configured with value 2048 gets twice as much CPU time as a VM configured with value 1024.
     * - quota:cpu_shares_level - On VMware, specifies the allocation level. Can be custom, high, normal, or low. If you choose custom, set the number of shares using cpu_shares_share.
     * - quota:cpu_period - Specifies the enforcement interval (unit: microseconds) for QEMU and LXC hypervisors. Within a period, each VCPU of the domain is not allowed to consume more than the quota worth of runtime. The value should be in range [1000, 1000000]. A period with value 0 means no value.
     * - quota:cpu_limit - Specifies the upper limit for VMware machine CPU allocation in MHz. This parameter ensures that a machine never uses more than the defined amount of CPU time. It can be used to enforce a limit on the machine's CPU performance.
     * - quota:cpu_reservation - Specifies the guaranteed minimum CPU reservation in MHz for VMware. This means that if needed, the machine will definitely get allocated the reserved amount of CPU cycles.
     * - quota:cpu_quota - Specifies the maximum allowed bandwidth (unit: microseconds). A domain with a negative-value quota indicates that the domain has infinite bandwidth, which means that it is not bandwidth controlled. The value should be in range [1000, 18446744073709551] or less than 0. A quota with value 0 means no value. You can use this feature to ensure that all vCPUs run at the same speed.
     * 
     * **Memory limits:**
     * - quota:memory_limit - Specifies the upper limit for VMware machine memory allocation in MB. The utilization of a virtual machine will not exceed this limit, even if there are available resources. This is typically used to ensure a consistent performance of virtual machines independent of available resources.
     * - quota:memory_reservation - Specifies the guaranteed minimum memory reservation in MB for VMware. This means the specified amount of memory will definitely be allocated to the machine.
     * - quota:memory_shares_level - On VMware, specifies the allocation level. This can be custom, high, normal or low. If you choose custom, set the number of shares using memory_shares_share.
     * - quota:memory_shares_share - Specifies the number of shares allocated in the event that custom is used. There is no unit for this value. It is a relative measure based on the settings for other VMs.
     * 
     * **Disk I/O limits:**
     * - quota:disk_io_limit - Specifies the upper limit for disk utilization in I/O per second. The utilization of a virtual machine will not exceed this limit, even if there are available resources. The default value is -1 which indicates unlimited usage.
     * - quota:disk_io_reservation - Specifies the guaranteed minimum disk allocation in terms of Input/output Operations Per Second (IOPS).
     * - quota:disk_io_shares_level - Specifies the allocation level. This can be custom, high, normal or low. If you choose custom, set the number of shares using disk_io_shares_share.
     * - quota:disk_io_shares_share - Specifies the number of shares allocated in the event that custom is used. When there is resource contention, this value is used to determine the resource allocation.
     * 
     * **Disk tuning:**
     * - quota:disk_read_bytes_sec
     * - quota:disk_read_iops_sec
     * - quota:disk_write_bytes_sec
     * - quota:disk_write_iops_sec
     * - quota:disk_total_bytes_sec
     * - quota:disk_total_iops_sec
     * 
     * **Bandwidth I/O:**
     * - quota:vif_inbound_average
     * - quota:vif_inbound_burst
     * - quota:vif_inbound_peak
     * - quota:vif_outbound_average
     * - quota:vif_outbound_burst
     * - quota:vif_outbound_peak
     * 
     * **Watchdog behavior:**
     * - hw:watchdog_action
     * 
     * **Random-number generator:**
     * - hw_rng:rate-allowed
     * - hw_rng:rate_bytes
     * - hw_rng:rate_period
     * 
     * **CPU topology:**
     * - hw:cpu_sockets
     * - hw:cpu_cores
     * - hw:cpu_threads
     * - hw:cpu_max_sockets
     * - hw:cpu_max_cores
     * - hw:cpu_max_threads
     * 
     * **CPU pinning policy:**
     * - hw:cpu_policy
     * - hw:cpu_thread_policy
     * 
     * **NUMA topology:**
     * - hw:numa_nodes
     * - hw:numa_cpus.N
     * - hw:numa_mem.N
     * 
     * **Large pages allocation:**
     * - hw:mem_page_size
     * 
     * **PCI passthrough:**
     * - pci_passthrough:alias
     * 
     * **Secure Boot:**
     * - os:secure_boot
     * 
     * @type {string}
     * @memberof ClusterInstanceExtraSpec
     */
    key?: ClusterInstanceExtraSpecKeyEnum;
    /**
     * Extra Specification 의 Value
     * @type {string}
     * @memberof ClusterInstanceExtraSpec
     */
    value?: string;
}


/**
 * @export
 */
export const ClusterInstanceExtraSpecKeyEnum = {
    quotacpu_shares: 'quota:cpu_shares',
    quotacpu_shares_level: 'quota:cpu_shares_level',
    quotacpu_period: 'quota:cpu_period',
    quotacpu_limit: 'quota:cpu_limit',
    quotacpu_reservation: 'quota:cpu_reservation',
    quotacpu_quota: 'quota:cpu_quota',
    quotamemory_limit: 'quota:memory_limit',
    quotamemory_reservation: 'quota:memory_reservation',
    quotamemory_shares_level: 'quota:memory_shares_level',
    quotamemory_shares_share: 'quota:memory_shares_share',
    quotadisk_io_limit: 'quota:disk_io_limit',
    quotadisk_io_reservation: 'quota:disk_io_reservation',
    quotadisk_io_shares_level: 'quota:disk_io_shares_level',
    quotadisk_io_shares_share: 'quota:disk_io_shares_share',
    quotadisk_read_bytes_sec: 'quota:disk_read_bytes_sec',
    quotadisk_read_iops_sec: 'quota:disk_read_iops_sec',
    quotadisk_write_bytes_sec: 'quota:disk_write_bytes_sec',
    quotadisk_write_iops_sec: 'quota:disk_write_iops_sec',
    quotadisk_total_bytes_sec: 'quota:disk_total_bytes_sec',
    quotadisk_total_iops_sec: 'quota:disk_total_iops_sec',
    quotavif_inbound_average: 'quota:vif_inbound_average',
    quotavif_inbound_burst: 'quota:vif_inbound_burst',
    quotavif_inbound_peak: 'quota:vif_inbound_peak',
    quotavif_outbound_average: 'quota:vif_outbound_average',
    quotavif_outbound_burst: 'quota:vif_outbound_burst',
    quotavif_outbound_peak: 'quota:vif_outbound_peak',
    hwwatchdog_action: 'hw:watchdog_action',
    hw_rngrate_allowed: 'hw_rng:rate-allowed',
    hw_rngrate_bytes: 'hw_rng:rate_bytes',
    hw_rngrate_period: 'hw_rng:rate_period',
    hwcpu_sockets: 'hw:cpu_sockets',
    hwcpu_cores: 'hw:cpu_cores',
    hwcpu_threads: 'hw:cpu_threads',
    hwcpu_max_sockets: 'hw:cpu_max_sockets',
    hwcpu_max_cores: 'hw:cpu_max_cores',
    hwcpu_max_threads: 'hw:cpu_max_threads',
    hwcpu_policy: 'hw:cpu_policy',
    hwcpu_thread_policy: 'hw:cpu_thread_policy',
    hwnuma_nodes: 'hw:numa_nodes',
    hwnuma_cpus_n: 'hw:numa_cpus.N',
    hwnuma_mem_n: 'hw:numa_mem.N',
    hwmem_page_size: 'hw:mem_page_size',
    pci_passthroughalias: 'pci_passthrough:alias',
    ossecure_boot: 'os:secure_boot'
} as const;
export type ClusterInstanceExtraSpecKeyEnum = typeof ClusterInstanceExtraSpecKeyEnum[keyof typeof ClusterInstanceExtraSpecKeyEnum];


/**
 * Check if a given object implements the ClusterInstanceExtraSpec interface.
 */
export function instanceOfClusterInstanceExtraSpec(value: object): boolean {
    let isInstance = true;

    return isInstance;
}

export function ClusterInstanceExtraSpecFromJSON(json: any): ClusterInstanceExtraSpec {
    return ClusterInstanceExtraSpecFromJSONTyped(json, false);
}

export function ClusterInstanceExtraSpecFromJSONTyped(json: any, ignoreDiscriminator: boolean): ClusterInstanceExtraSpec {
    if ((json === undefined) || (json === null)) {
        return json;
    }
    return {
        
        'key': !exists(json, 'key') ? undefined : json['key'],
        'value': !exists(json, 'value') ? undefined : json['value'],
    };
}

export function ClusterInstanceExtraSpecToJSON(value?: ClusterInstanceExtraSpec | null): any {
    if (value === undefined) {
        return undefined;
    }
    if (value === null) {
        return null;
    }
    return {
        
        'key': value.key,
        'value': value.value,
    };
}

